## 동시성 이슈

동시에 여러 요청이 전달되면 동시성 이슈가 발생할 수 있다.

둘 이상의 스레드가 동일한 데이터에 접근하여 동시에 변경을 시도하는 레이스 컨디션이 발생하기 때문이다.

예를 들어, 입찰 요청이 동시에 전달되면 최고 입찰가가 높은 금액에서 낮은 금액으로 변경되는 현상이 발생할 수 있다.

## 해결 방법

각 스레드가 순차적으로 작업을 완료할 수 있도록 제어해야 한다.

1. **synchronized**
2. **Database**
    - Pessimistic Lock
    - Optimistic Lock
    - Named Lock
3. **Redis**

### synchronized

코드 레벨에서 동시성을 제어하는 방법이다.

메서드 선언부에 synchronized 키워드를 붙이면 해당 메서드는 하나의 스레드만 접근할 수 있다.

**[synchronized를 이용했을 때 발생할 수 있는 문제]**

만약 여러 서버를 사용할 경우 synchronized로는 문제를 해결할 수 없다. 각 서버에서는 문제가 해결돼도 전체적으로 봤을 때 문제는 여전히 존재한다.

이러한 경우 코드 레벨에서 해결하면 안 되며, 단일 지점인 DB에서 동시성 문제를 제어해야 한다.

### Database

1. **Pessimistic Lock**
    - 실제로 데이터에 Lock을 걸어서 정합성을 맞추는 방법이다.
    - exclusive lock 을 걸게 되면 다른 트랜잭션에서는 lock이 해제되기 전에 데이터를 가져갈 수 없게 된다.
    - **데드락**이 발생할 수 있기때문에 주의해야 한다.
    
    ```java
    Transaction A:  [ Lock ] ─────────────> [ Modify ] ─────────────> [ Release ]
                                                              ↓
    Transaction B:    ─────────────> [ Wait ] ───────────────────────────────> [ Modify ]
    ```
    
    **[구현 방법]**
    
    Spring Data JPA를 사용하면 @Lock 애너테이션으로 손쉽게 Pessimistic Lock을 구현할 수 있다.
    
    `@Lock(LockModeType.PESSIMISTIC_WRITE)`
    
    **[장점]**
    
    - 충돌이 빈번히 발생할 수 있다면 Optimistic Lock보다 성능이 좋을 수 있다.
    - Lock을 통해 업데이트를 제어하기 때문에 데이터 정합성이 보장된다.
    
    **[단점]**
    
    Lock 설정이 성능 감소로 이어질 수 있다.
    
2. **Optimistic Lock**
    - Lock 을 이용하지 않고 **버전을 이용**해서 정합성을 맞추는 방법이다.
    - 데이터 읽고 업데이트를 수행할 때 읽었을 때와 동일한 버전인지 확인한다. 동일한 버전인 경우 업데이트한다. 버전이 더 높아진 경우 다른 트랜잭션에서 먼저 변경한 것이기 때문에 정상 처리를 위해 애플리케이션에서 데이터를 다시 읽은 후 작업을 처리한다.

```java
Transaction A:  [ Read (V1) ] ─────────> [ Modify ] ─────────> [ Commit (V2) ]
Transaction B:  [ Read (V1) ] ─────────> [ Modify ] ─────────> [ Fail (V1 ≠ V2) ]
```

**[구현 방법]**

1. 버전 컬럼 추가 및 @Version 애너테이션 적용
    
    `@Version (javax.persistence 패키지)`
    
2. @Lock 애너테이션 적용
    
    `@Lock(LockModeType.OPTIMISTIC)`
    
3. 업데이트 실패 시 재시도하는 로직 추가
    
    

**[장점]**

Lock을 설정하지 않기 때문에 Pessimistic Lock보다 성능 상 이점이 있다.

**[단점]**

업데이트 실패 시 재시도하는 로직을 직접 작성해야 하는 번거로움이 있다.

1. **Named Lock**
    - 이름을 가진 metadata locking 기법이다. 이름을 가진 lock 을 획득한 후 해제될 때까지 다른 세션은 이 lock 을 획득할 수 없도록 한다.
    - row 또는 table이 아닌 metadata에 lock을 적용한다.
    - 주의할 점은 트랜잭션이 종료될 때 lock 이 자동으로 해제되지 않기 때문에 별도의 명령어로 해제를 수행하거나 선점 시간이 만료되어 해제될 때까지 기다려야 한다.
    - 주로 분산 락 구현 시 사용한다.

```java
Transaction A:  [ Lock ("Resource X") ] ─────────> [ Modify ] ─────────> [ Release ]
                                                                ↓
Transaction B:    ─────────────> [ Wait ] ───────────────────────────────> [ Lock ] ─────────> [ Modify ]
```

**[구현 방법]**

1. get_lock, release_lock

**[장점]**

- Pessimistic Lock의 경우 타임아웃 구현이 어렵지만 Named Lock은 타임아웃 구현이 쉬운 편이다.
- 데이터 삽입 시 정합성을 맞춰야 하는 경우에도 적합하다.

**[단점]**

트랜잭션 종료 시 락 해제, 세션 관리를 잘 해주어야 하며, 실제로 적용 시 구현이 복잡할 수 있다.

실무에서는 데이터 소스는 분리해서 사용하는 것이 좋다. 같은 데이터 소스를 사용하면 커넥션 풀이 부족해지는 현상이 발생할 수 있어서 다른 서비스에서 영향을 줄 수 있다.

### Redis

redis를 활용해서 동시성 문제를 해결할 때 사용하는 대표적 라이브러리는 **Lettuce, Redisson** 두 가지가 있다.

1. **Lettuce**
    - setnx 명령어를 활용하여 분산 락 구현
        - key와 value를 set하려고 할 때 기존 값이 없는 경우에만 set 수행
    - spin lock 방식
        - 락을 획득하려는 스레드가 락을 사용할 수 있는지 반복적으로 확인하며 락 획득을 시도하는 방식
        - 리트라이 로직 구현 필요
    
    MySQL의 Named Lock과 비슷하다. 다른 점은 Redis를 이용한다는 점과 Session 관리에 신경을 쓰지 않아도 된다는 점이다.
    
    만약 락 획득에 실패했다면 Thread.sleep(100); 메서드를 활용해서 100ms의 텀을 두고 락 획득을 재시도한다. 이렇게 해야 Redis의 부하를 낮출 수 있다.
    
    **[장점]**
    
    구현이 간단하다.
    
    **[단점]**
    
    스핀 락 방식이기 때문에 반복적인 락 획득 시도로인해 Redis에 부하를 줄 수 있다.
    
2. **Redisson**
    - pub-sub 기반의 lock 구현 제공
        - 채널을 만들고 락을 점유 중인 스레드가 채널을 구독한 락 획득 대기 스레드에게 해제를 알린 후, 메시지를 받은 스레드가 락 획득을 시도하는 방식
        - Lettuce와는 달리 리트라이 로직 작성이 필요하지 않음
    
    락을 획득하고자 하는 스레드들은 메시지를 받았을 때만 락 획득을 시도한다. 그렇기 때문에 Lettuce처럼 일정 시간마다 반복적으로 요청을 보내지 않으며 부하를 줄일 수 있다.
    
    **[장점]**
    
    Pub Sub 기반이기 때문에 부하를 낮출 수 있다.
    
    **[단점]**
    
    구현이 복잡하며, 별도 라이브러리 사용이 필요하다.
    

## MySQL과 Redis의 장단점

실무에서는 비용적 여유가 없거나, MySQL로 처리 가능할 정도의 트래픽이라면 MySQL을 활용한다.

비용적 여유가 있거나, MySQL로는 처리가 불가능할 정도의 트래픽이 발생하는 경우 Redis를 도입한다.

### MySQL

**[장점]**

- 이미 MySQL을 사용하고 있을 경우 별도 비용 없이 동시성 이슈 해결 방법 적용이 가능하다.
- 성능이 Redis보다 좋지는 않지만 어느 정도의 트래픽까지는 문제 없이 사용 가능하다.

**[단점]**

Redis보다는 성능이 좋지 않다.

### Redis

**[장점]**

MySQL보다 성능이 우수하기 때문에 더 많은 요청을 처리할 수 있다.

**[단점]**

활용 중인 Redis가 없을 경우 별도 구축 비용과 인프라 관리 비용이 추가로 발생한다.
