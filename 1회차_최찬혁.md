## 1. 동시성 문제가 발생하는 상황

> 간단한 재고 감소 상황에서도 동시성 이슈가 발생할 수 있다.

그 이유는 `값을 수정하는 행위`의 특징 때문이다.
값을 다시 쓴다는 것은 결국 `조회-수정-저장`의 작업을 의미하는데 바로 저 조회와 저장 사이에 2개 이상의 스레드가 동시에 같은 값에 접근하는 경우 문제가 생긴다.
대표적인 동시성 문제의 예시로 `레이스 컨디션`이라고 표현할 수 있는데 코드를 통해 확인해보자.


```
public void productService {
    ..

    public void 상품_재고_감소(Long 업데이트_대상_상품_id) {
      상품 업데이트_대상_상품정보 = 상품정보_저장소.특정_id의_상품_정보_조회(업데이트_대상_상품_id);
      Long 업데이트_대상_상품수량 = 업데이트_대상_상품정보.상품수량_가져오기();

      업데이트_대상_상품정보.상품수량_업데이트(업데이트_대상_상품수량-1);

      ..
    }

}
```

<br>

> Q1. 위 코드에 문제가 없어 보이는가?

.. 맞다. 로직상엔 문제가 없다. 하지만 내가 구축한 애플리케이션이 `멀티 스레드`를 지원하는 경우라면 문제가 발생할 수 있다. 아래 경우를 보자.

### [작업 순서]


#### [task1. 재고 감소 요청]
- 스레드1: A상품에 대한 재고 감소 요청을 받았다.
- 스레드2: A상품에 대한 재고 감소 요청을 받았다.

#### [task2. 현재 재고 조회]
- 스레드1: A상품의 현재 재고를 조회한다 (stock:4)
- 스레드2: A상품의 현재 재고를 조회한다 (stock:4)

#### [task3. 현재 재고에서 1 감소]
- 스레드1: A상품의 현재 재고에서 1을 뺸다 (updateStock: 3)
- 스레드2: A상품의 현재 재고에서 1을 뺀다 (updateStock: 3)

#### [task4. 감소한 수정 재고를 db에 기록]
- 스레드1: DB에 A상품의 재고를 3으로 저장
- 스레드2: DB에 A상품의 재고를 3으로 저장


<br>

천천히 위 흐름을 읽어보자. 문제가 보이는가? 그렇다 재고 감소 요청은 2건이 일어났는데 실제 감소한 재고는 한 건 뿐이다. 왜 그럴까? 바로 조회 시점이 같아 애초에 감소해야 하는 원본 데이터의 값이 같기 때문이다.


<br>


## 2. 레이스 컨디션을 해결하는 방법

> Q2. 그럼 어떻게 해결해야할까?

가장 간단한 방법은 `synchronized`를 이용해 메서드 레벨이나 블록 레벨에 락을 거는 방법이다. 무조건 하나의 스레드씩만 저 작업을 수행할 수 있게 점유 가능토록 하는 정책을 적용하는 것이다.


<br>

> Q3. 정말 동시성 문제가 해결된 걸까?

사실은 아니다. synchronized를 적용한 문제 해결은 사실 하나의 인스턴스에서 서비스가 돌아가는 상태에서만 유효하다. 로드밸런서를 두고 부하를 분산하는 멀티 인스턴스 환경에선 DB레벨의 락이나 레디스 같은 도구들을 이용해
문제를 해결해볼법하다.





