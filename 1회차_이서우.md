## 동시성 이슈

동시에 여러 요청이 전달되면 동시성 이슈가 발생할 수 있다.

둘 이상의 스레드가 동일한 데이터에 접근하여 동시에 변경을 시도하는 레이스 컨디션이 발생하기 때문이다.

예를 들어, 입찰 요청이 동시에 전달되면 최고 입찰가가 높은 금액에서 낮은 금액으로 변경되는 현상이 발생할 수 있다.

## 해결 방법

각 스레드가 순차적으로 작업을 완료할 수 있도록 제어해야 한다.

### synchronized

코드 레벨에서 동시성을 제어하는 방법이다.

메서드 선언부에 synchronized 키워드를 붙이면 해당 메서드는 하나의 스레드만 접근할 수 있다.

**[synchronized를 이용했을 때 발생할 수 있는 문제]**

만약 여러 서버를 사용할 경우 synchronized로는 문제를 해결할 수 없다. 각 서버에서는 문제가 해결돼도 전체적으로 봤을 때 문제는 여전히 존재한다.

이러한 경우 코드 레벨에서 해결하면 안 되며, 단일 지점인 DB에서 동시성 문제를 제어해야 한다.

### Database

1. **Pessimistic Lock**
    - 실제로 데이터에 Lock 을 걸어서 정합성을 맞추는 방법이다.
    - exclusive lock 을 걸게되며 다른 트랜잭션에서는 lock 이 해제되기 전에 데이터를 가져갈 수 없게 된다.
    - **데드락**이 발생할 수 있기때문에 주의해야 한다.
2. **Optimistic Lock**
    - Lock 을 이용하지 않고 버전을 이용해서 정합성을 맞추는 방법이다.
    - 먼저 데이터를 읽은 후 업데이트를 수행할 때 현재 내가 읽은 버전이 맞는지 확인하며 업데이트 한다. 내가 읽은 버전에서 수정 사항이 생겼을 경우 애플리케이션에서 다시 읽은 후에 작업을 수행해야 한다.
3. **Named Lock**
    - 이름을 가진 metadata locking 기법이다. 이름을 가진 lock 을 획득한 후 해제될 때까지 다른 세션은 이 lock 을 획득할 수 없도록 한다.
    - 주의할 점은 트랜잭션이 종료될 때 lock 이 자동으로 해제되지 않기 때문에 별도의 명령어로 해제를 수행하거나 선점 시간이 만료되어 해제될 때까지 기다려야 한다.
